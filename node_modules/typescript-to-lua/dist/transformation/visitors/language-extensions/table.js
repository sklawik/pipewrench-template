"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tableExtensionTransformers = exports.tableNewExtensions = exports.isTableNewCall = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const language_extensions_1 = require("../../utils/language-extensions");
const expression_list_1 = require("../expression-list");
function isTableNewCall(context, node) {
    return (0, language_extensions_1.getExtensionKindForNode)(context, node.expression) === language_extensions_1.ExtensionKind.TableNewType;
}
exports.isTableNewCall = isTableNewCall;
exports.tableNewExtensions = [language_extensions_1.ExtensionKind.TableNewType];
exports.tableExtensionTransformers = {
    [language_extensions_1.ExtensionKind.TableDeleteType]: transformTableDeleteExpression,
    [language_extensions_1.ExtensionKind.TableDeleteMethodType]: transformTableDeleteExpression,
    [language_extensions_1.ExtensionKind.TableGetType]: transformTableGetExpression,
    [language_extensions_1.ExtensionKind.TableGetMethodType]: transformTableGetExpression,
    [language_extensions_1.ExtensionKind.TableHasType]: transformTableHasExpression,
    [language_extensions_1.ExtensionKind.TableHasMethodType]: transformTableHasExpression,
    [language_extensions_1.ExtensionKind.TableSetType]: transformTableSetExpression,
    [language_extensions_1.ExtensionKind.TableSetMethodType]: transformTableSetExpression,
    [language_extensions_1.ExtensionKind.TableAddKeyType]: transformTableAddExpression,
    [language_extensions_1.ExtensionKind.TableAddKeyMethodType]: transformTableAddExpression,
};
function transformTableDeleteExpression(context, node, extensionKind) {
    const args = node.arguments.slice();
    if (extensionKind === language_extensions_1.ExtensionKind.TableDeleteMethodType &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    const [table, accessExpression] = (0, expression_list_1.transformExpressionList)(context, args);
    // arg0[arg1] = nil
    context.addPrecedingStatements(lua.createAssignmentStatement(lua.createTableIndexExpression(table, accessExpression), lua.createNilLiteral(), node));
    return lua.createBooleanLiteral(true);
}
function transformWithTableArgument(context, node) {
    if (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression)) {
        return (0, expression_list_1.transformExpressionList)(context, [node.expression.expression, ...node.arguments]);
    }
    // todo: report diagnostic?
    return [lua.createNilLiteral(), ...(0, expression_list_1.transformExpressionList)(context, node.arguments)];
}
function transformTableGetExpression(context, node, extensionKind) {
    const args = extensionKind === language_extensions_1.ExtensionKind.TableGetMethodType
        ? transformWithTableArgument(context, node)
        : (0, expression_list_1.transformExpressionList)(context, node.arguments);
    const [table, accessExpression] = args;
    // arg0[arg1]
    return lua.createTableIndexExpression(table, accessExpression, node);
}
function transformTableHasExpression(context, node, extensionKind) {
    const args = extensionKind === language_extensions_1.ExtensionKind.TableHasMethodType
        ? transformWithTableArgument(context, node)
        : (0, expression_list_1.transformExpressionList)(context, node.arguments);
    const [table, accessExpression] = args;
    // arg0[arg1]
    const tableIndexExpression = lua.createTableIndexExpression(table, accessExpression);
    // arg0[arg1] ~= nil
    return lua.createBinaryExpression(tableIndexExpression, lua.createNilLiteral(), lua.SyntaxKind.InequalityOperator, node);
}
function transformTableSetExpression(context, node, extensionKind) {
    const args = extensionKind === language_extensions_1.ExtensionKind.TableSetMethodType
        ? transformWithTableArgument(context, node)
        : (0, expression_list_1.transformExpressionList)(context, node.arguments);
    const [table, accessExpression, value] = args;
    // arg0[arg1] = arg2
    context.addPrecedingStatements(lua.createAssignmentStatement(lua.createTableIndexExpression(table, accessExpression), value, node));
    return lua.createNilLiteral();
}
function transformTableAddExpression(context, node, extensionKind) {
    const args = extensionKind === language_extensions_1.ExtensionKind.TableAddKeyMethodType
        ? transformWithTableArgument(context, node)
        : (0, expression_list_1.transformExpressionList)(context, node.arguments);
    const [table, value] = args;
    // arg0[arg1] = true
    context.addPrecedingStatements(lua.createAssignmentStatement(lua.createTableIndexExpression(table, value), lua.createBooleanLiteral(true), node));
    return lua.createNilLiteral();
}
//# sourceMappingURL=table.js.map