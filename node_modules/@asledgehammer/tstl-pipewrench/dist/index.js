"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const ajv_1 = __importDefault(require("ajv"));
const config_1 = require("./config");
const ajv = new ajv_1.default();
const REIMPORT_TEMPLATE = fs
    .readFileSync(path_1.default.join(__dirname, '../lua/reimport_template.lua'))
    .toString();
const fixRequire = (scope, lua) => {
    if (lua.length === 0)
        return '';
    const fix = (fromImport) => {
        let toImport = fromImport.replace(/\./g, '/');
        // Remove cross-references for client/server/shared.
        if (toImport.startsWith('shared/')) {
            toImport = toImport.substring('shared/'.length);
        }
        else if (toImport.startsWith('client/')) {
            if (scope === 'server') {
                console.warn(`Cannot reference code from src/client from src/server. ` +
                    '(Code will fail when ran)');
            }
            toImport = toImport.substring('client/'.length);
        }
        else if (toImport.startsWith('server/')) {
            if (scope === 'client') {
                console.warn(`Cannot reference code from src/server from src/client. ` +
                    '(Code will fail when ran)');
            }
            toImport = toImport.substring('server/'.length);
        }
        return toImport;
    };
    let index = -1;
    do {
        let fromImport = '';
        index = lua.indexOf('require("');
        if (index !== -1) {
            index += 9;
            // Grab the require string.
            while (index < lua.length) {
                const char = lua.charAt(index++);
                if (char === '"')
                    break;
                fromImport += char;
            }
            const toImport = fix(fromImport);
            // Kahlua only works with '/', nor '.' in 'require(..)'.
            const from = 'require("' + fromImport + '")';
            const to = "require('" + toImport.replace(/\./g, '/') + "')";
            lua = lua.replace(from, to);
        }
    } while (index !== -1);
    return lua;
};
const applyReimportScript = (lua) => {
    const assignments = [];
    const lines = lua.split('\n');
    // Look for any PipeWrench assignments.
    for (const line of lines) {
        if (line.indexOf('local ') === 0 &&
            line.indexOf('____pipewrench.') !== -1) {
            assignments.push(line.replace('local ', ''));
        }
    }
    // Only generate a reimport codeblock if there's anything to import.
    if (!assignments.length)
        return lua;
    // Take out the returns statement so we can insert before it.
    lines.pop();
    const returnLine = lines.pop();
    lines.push('');
    // Build the reimport event.
    let compiledImports = '';
    for (const assignment of assignments)
        compiledImports += `${assignment}\n`;
    const reimports = REIMPORT_TEMPLATE.replace('-- {IMPORTS}', compiledImports.substring(0, compiledImports.length - 1));
    return `${lines.join('\n')}\n${reimports}\n\n${returnLine}\n`;
};
const handleFile = (file) => {
    if (file.code.length === 0)
        return;
    let scope = 'none';
    const fp = path_1.default.parse(file.outputPath);
    if (fp.dir.indexOf('client'))
        scope = 'client';
    else if (fp.dir.indexOf('server'))
        scope = 'server';
    else if (fp.dir.indexOf('shared'))
        scope = 'shared';
    const split = fp.dir.split('lua_modules');
    const isLuaModule = split.length > 1;
    if (fp.name === 'lualib_bundle') {
        file.outputPath = path_1.default.join(fp.dir, 'shared/lualib_bundle.lua');
    }
    if (isLuaModule) {
        file.outputPath = path_1.default.join(split[0], 'shared', 'lua_modules', ...split.slice(1), fp.base);
    }
    file.code = applyReimportScript(fixRequire(scope, file.code));
};
const copyMake = (src, dest) => {
    fs.ensureDirSync(dest);
    fs.copySync(src, dest, { recursive: true });
};
class PipeWrenchPlugin {
    config;
    constructor() {
        const validateConfig = ajv.compile(config_1.PipeWrenchConfigSchema);
        const rawdata = fs.readFileSync('./pipewrench.json');
        const rawConfig = JSON.parse(rawdata.toString());
        if (validateConfig(rawConfig)) {
            this.config = rawConfig;
            console.log('Configuration:', this.config);
        }
        else {
            console.error(validateConfig.errors);
            throw 'Error parsing pipewrench.json';
        }
    }
    beforeTransform(program, options, emitHost) {
        if (!options.outDir) {
            throw 'Must specify outDir in tsconfig.json';
        }
        return;
    }
    beforeEmit(program, options, emitHost, result) {
        if (options.outDir) {
            const modSubDir = path_1.default.join(options.outDir, this.config.modInfo.id);
            fs.ensureDirSync(modSubDir);
            if ((0, fs_1.existsSync)(this.config.modelsDir))
                copyMake(this.config.modelsDir, path_1.default.join(modSubDir, 'media', 'models'));
            if ((0, fs_1.existsSync)(this.config.texturesDir))
                copyMake(this.config.texturesDir, path_1.default.join(modSubDir, 'media', 'textures'));
            if ((0, fs_1.existsSync)(this.config.soundDir))
                copyMake(this.config.soundDir, path_1.default.join(modSubDir, 'media', 'sound'));
            if ((0, fs_1.existsSync)(this.config.scriptsDir))
                copyMake(this.config.scriptsDir, path_1.default.join(modSubDir, 'media', 'scripts'));
            const modInfoArray = Object.entries(this.config.modInfo).map(([key, value]) => {
                return `${key}=${value}`;
            });
            (0, fs_1.writeFileSync)(path_1.default.join(modSubDir, 'mod.info'), modInfoArray.join('\n'));
            result.map((file) => {
                const { outDir } = options;
                if (outDir) {
                    file.outputPath = path_1.default.join(modSubDir, 'media', 'lua', path_1.default.relative(outDir, file.outputPath));
                    handleFile(file);
                }
            });
        }
    }
}
const plugin = new PipeWrenchPlugin();
exports.default = plugin;
